<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>cool-fire</title><link href="http://saerdna.github.io/" rel="alternate"></link><link href="http://saerdna.github.io/feeds/saerdna.atom.xml" rel="self"></link><id>http://saerdna.github.io/</id><updated>2015-01-01T12:43:13+08:00</updated><entry><title>关于库存服务的架构设计</title><link href="http://saerdna.github.io/posts/technology/arch%20design%20of%20stock%20service-zh.html" rel="alternate"></link><updated>2015-01-01T12:43:13+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2015-01-01:posts/technology/arch design of stock service-zh.html</id><summary type="html">&lt;p&gt;最近在负责&lt;del&gt;某司&lt;/del&gt;的库存服务改造项目。&lt;/p&gt;
&lt;p&gt;其实就是设计一个秒杀系统，让商品在极端的抢购环境下可以正常的扣减库存，同时不会超卖。&lt;/p&gt;
&lt;p&gt;公司的项目已基本弄完，剩下的就是一些后期优化的工作。&lt;/p&gt;
&lt;p&gt;在此整理一下设计要点，未来一段时间会考虑做一个开源版本，希望可以作成一个通用服务。&lt;/p&gt;
&lt;h3&gt;整体架构&lt;/h3&gt;
&lt;p&gt;由上至下分为3层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基础服务层&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;逻辑层&lt;/h4&gt;
&lt;p&gt;逻辑层主要负责数据处理以及分发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收外部系统的请求并分发。&lt;/li&gt;
&lt;li&gt;调用数据层获取原始数据拼装并返回&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;数据层&lt;/h4&gt;
&lt;p&gt;逻辑层主要负责数据获取&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同数据库进行交互。&lt;/li&gt;
&lt;li&gt;同消息队列进行交互&lt;/li&gt;
&lt;li&gt;本地cache交互&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;基础服务层&lt;/h4&gt;
&lt;p&gt;基础服务层主要对外部系统提供的一些接口针对性的封装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;日志打印&lt;/li&gt;
&lt;li&gt;MQ（消息队列）&lt;/li&gt;
&lt;li&gt;local-cache&lt;/li&gt;
&lt;li&gt;模块监控&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;存储设计&lt;/h3&gt;
&lt;p&gt;to be continue...&lt;/p&gt;</summary></entry><entry><title>AudioToArtImage工具</title><link href="http://saerdna.github.io/posts/technology/AudioToArtImage-zh.html" rel="alternate"></link><updated>2014-12-27T17:13:05+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2014-12-27:posts/technology/AudioToArtImage-zh.html</id><summary type="html">&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;这个项目是通过萌萌介绍给我的，算是第一个练手的小项目。&lt;/p&gt;
&lt;p&gt;对方的需求是将一小段音频转成一个酷炫的图片，效果类似 &lt;a href="http://weavesilk.com/"&gt;weavesilk.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="http://saerdna.github.io/images/AudioToArtImage.png" /&gt;&lt;/p&gt;
&lt;p&gt;在同&lt;a href="http://lingyu.wang/"&gt;教皇大神&lt;/a&gt;讨论了下技术实现之后果断决定揽下这个&lt;del&gt;坑爹项目&lt;/del&gt;.&lt;/p&gt;
&lt;h3&gt;用户需求&lt;/h3&gt;
&lt;p&gt;主要为以下几点.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;音频批处理功能&lt;/li&gt;
&lt;li&gt;指定输入输出目录&lt;/li&gt;
&lt;li&gt;圣诞前完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一眼看上去，这个需求比较简单，但是仔细一想，其实坑挺多。有一些潜在的需求其实是客户没有直接描述的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作简单&lt;/li&gt;
&lt;li&gt;windows下运行&lt;/li&gt;
&lt;li&gt;酷炫的效果&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;设计架构&lt;/h3&gt;
&lt;p&gt;考虑到时间的紧迫性以及技术熟练程度，采用的技术架构如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户界面采用html+css+js，也就是传统的web前端界面。&lt;/li&gt;
&lt;li&gt;图像生成模块利用&lt;a href="http://weavesilk.com/"&gt;weavesilk.com&lt;/a&gt;原生的代码，在原来的基础上做一些接口化的开发和调整。&lt;/li&gt;
&lt;li&gt;音频处理模块以及web后端采用python进行开发。&lt;/li&gt;
&lt;li&gt;前端使用浏览器打开，后端使用webpy搭建一个本地的httpserver。&lt;/li&gt;
&lt;li&gt;使用pyinstaller生成可执行程序来进行win下的兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;交互流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;前端选定音频文件后，将音频文件POST到后端&lt;/li&gt;
&lt;li&gt;后端提取音频特征后，生成鼠标轨迹数据，并返回给前端。&lt;/li&gt;
&lt;li&gt;前端利用canvas绘制好图片，将图片数据再POST回后端。&lt;/li&gt;
&lt;li&gt;后端将图片写到指定目录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;音频处理模块&lt;/h3&gt;
&lt;p&gt;一开始设计的时候，希望是能兼容几种比较主流的音频(mp3,wav,wma)。&lt;/p&gt;
&lt;p&gt;在深入了解了一下音频这块的技术后，果断决定只支持wav格式。&lt;/p&gt;
&lt;p&gt;一方面是开发周期比较短，另外一方面是python这块没有比较好的库可以支持,
参考&lt;a href="http://sebug.net/paper/books/scipydoc/wave_pyaudio.html"&gt;声音的输入输出&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;绘制图片&lt;/h3&gt;
&lt;p&gt;模拟鼠标轨迹来绘制图片这一块着实花了很大的心思来弄。&lt;/p&gt;
&lt;p&gt;有两个比较坑的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;js的异步执行机制，你没有办法像同步模型下进行如下的操作。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;mouse.down(x, y)
sleep(sec)
mouse.move(x, y)
sleep(sec)
mouse.up(x,y)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;最后采取的方式是人工计算延迟&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code class = "hljs javascript"&gt;setTimeout(sleepMove(poi), tot);
tot += Number(time_delay);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为前端绘图是在一个canvas里面操作(别问我为啥不在多个canvas操作，weavesilk.com的代码改起来还是很花时间的。。)&lt;/p&gt;
&lt;p&gt;所以需要对canvas加一个&lt;strong&gt;互斥锁&lt;/strong&gt;，防止两份音频生成的鼠标轨迹同时画在canvas上。&lt;/p&gt;
&lt;p&gt;最后采用的方法是在server端加锁，每一个音频上传的upload方法里&lt;strong&gt;加锁&lt;/strong&gt;，每一张图片saver的时候&lt;strong&gt;锁释放&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样可以防止canvas重绘的情况发生&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;前端交互&lt;/h3&gt;
&lt;p&gt;文件上传使用的是&lt;a href="http://www.plupload.com/"&gt;plupload&lt;/a&gt;插件&lt;/p&gt;
&lt;p&gt;在设计&lt;strong&gt;指定输入输出目录&lt;/strong&gt;这个功能时,chrome的沙盒机制使得我没法在前端获取用户上传文件的路径。&lt;/p&gt;
&lt;p&gt;当时有2个备选方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户直接编辑配置文件&lt;/li&gt;
&lt;li&gt;上传文件夹采取拖动的方式，指定输出文件夹的功能同后台实时交互，需要实现&lt;code&gt;ls,cd&lt;/code&gt;这两个功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个方案不用说，交互太挫，肯定会被拍回来&lt;/p&gt;
&lt;p&gt;第二个方案的工作量也不小，而且在前端展示目录树也是需要耗费不少精力的。&lt;/p&gt;
&lt;p&gt;最后考虑到用户交互的简单性，我决定在用户生成图片时&lt;strong&gt;弹出一个对话框&lt;/strong&gt;让用户填入输出目录。这样既能避免用户直接编辑配置文件的差体验，也降低了开发的工作量。&lt;/p&gt;
&lt;p&gt;事实证明这样的效果还不错，客户看到这个实现还是比较满意的。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;这次做私活还是有不少收益的，技术深度可能没有太大的增加，但是技术广度确实得到了不少提升。&lt;/p&gt;
&lt;p&gt;同时对js，css这块的也由之前的未入门到现在的刚入门。&lt;/p&gt;
&lt;p&gt;同时也感叹，私活不好找啊。以后多扩展下这方面的资源，在以后自己出来创业之前通过私活积累足够的资金和技术广度。&lt;/p&gt;</summary></entry><entry><title>python中post数组参数</title><link href="http://saerdna.github.io/posts/skill/how_to_post_array_with_python-zh.html" rel="alternate"></link><updated>2014-12-06T10:56:00+08:00</updated><author><name>saerdna</name></author><id>tag:saerdna.github.io,2014-12-06:posts/skill/how_to_post_array_with_python-zh.html</id><summary type="html">&lt;p&gt;今天在写自动预约抢购的模块时发现的问题&lt;/p&gt;
&lt;p&gt;需要向网站post这样的数据&lt;code&gt;{'key':[1,2,3]}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;post的结果是&lt;code&gt;key=1&amp;amp;key=2&amp;amp;key=3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大家都知道在python对参数做序列化是urlencode,可是直接urlencode的结果如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [1]: import urllib
In [2]: help(urllib.urlencode)
In [3]: post_data = {'key':[1,2,3]}
In [4]: urllib.urlencode(post_data)
Out[4]: 'key=%5B1%2C+2%2C+3%5D'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查了下stackoverflow，还是有人遇到同样的问题，解决方案是urlencode时加上一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [1]: import urllib
In [2]: help(urllib.urlencode)
In [3]: post_data = {'key':[1,2,3]}
In [4]: urllib.urlencode(post_data, True)
Out[4]: 'key=1&amp;key=2&amp;key=3'
&lt;/code&gt;&lt;/pre&gt;</summary><category term="tech"></category><category term="python"></category><category term="web"></category></entry><entry><title>在mac下安装pyv8</title><link href="http://saerdna.github.io/posts/skill/install_pyv8_in_mac-zh.html" rel="alternate"></link><updated>2014-12-06T02:56:00+08:00</updated><author><name>saerdna</name></author><id>tag:saerdna.github.io,2014-12-06:posts/skill/install_pyv8_in_mac-zh.html</id><summary type="html">&lt;h3&gt;需求起因&lt;/h3&gt;
&lt;p&gt;最近在写一个自动登录网站并执行某些操作的模块。&lt;/p&gt;
&lt;p&gt;网站在js中加了token，需要在登录的时候传过去做校验。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var JSP_VAR={
  callback:"callbackurl",
  sid:"sid",
  qs:"qs_string",
  hidden:"",
  "_sign":"token",
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;尝试解决&lt;/h3&gt;
&lt;p&gt;开始尝试直接正则抠出字符串后&lt;code&gt;json.loads&lt;/code&gt;，发现和标准json不大一致，遂作罢。&lt;/p&gt;
&lt;p&gt;后来发现还有pyv8这种神奇的货色，考虑到以后需求肯定不单单是提取js的数据，也会有一些执行的东西，就想着试试。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;pip install pyv8&lt;/code&gt;后提示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;src/Exception.h:6:16: fatal error: v8.h: no such file or directory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考了这个哥们的文章之后发现还是不行，安装v8后没有出现boost部分的错误。building PyV8的时候报错了，&lt;a href="http://saerdna.github.io/files/pyv8_install_failed.log"&gt;错误日志&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;无奈之下只好找了个&lt;a href="https://github.com/brokenseal/PyV8-OS-X"&gt;PyV8-OS-X&lt;/a&gt;直接拿来用，缺点是以后移植到linux平台下还得改代码。&lt;/p&gt;
&lt;h5&gt;mac版：&lt;/h5&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;from pyv8 import PyV8
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h5&gt;linux版：&lt;/h5&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;import PyV8
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;为了这个事情都折腾半天了，实在不划算，对于一个程序员来说，折腾这种环境的事情实在太浪费时间了,下次一定得搞一台mini主机，开发运维啥的都统一到ubuntu，就不会有这些破事了。&lt;/p&gt;</summary><category term="tech"></category><category term="python"></category><category term="mac"></category><category term="web"></category></entry><entry><title>博客环境迁移遇到的问题</title><link href="http://saerdna.github.io/posts/tech/blog_environmental_move_problem-zh.html" rel="alternate"></link><updated>2014-12-01T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2014-12-01:posts/tech/blog_environmental_move_problem-zh.html</id><summary type="html">&lt;p&gt;在把博客的本地环境在 MBP 重新部署的时候遇到的.&lt;/p&gt;
&lt;p&gt;现象描述:&lt;/p&gt;
&lt;p&gt;pelican 发布博文时出现如下错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ImportError: No module named html_parser
&lt;img alt="1" src="http://saerdna.github.io/images/pelican_error.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;发现是 mac python 自带的 six module 库有问题.因为原生six 的 version 是1.4的,最新的已经到1.8了.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;six&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;six&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__version__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Solution:&lt;ul&gt;
&lt;li&gt;从 https://pypi.python.org/pypi/six/ 下载最新的 source. &lt;/li&gt;
&lt;li&gt;解压后执行 &lt;code&gt;sudo python setup.py install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>监督学习</title><link href="http://saerdna.github.io/posts/translate/supervised_learning-zh.html" rel="alternate"></link><updated>2014-12-01T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2014-12-01:posts/translate/supervised_learning-zh.html</id><summary type="html">&lt;h3&gt;&lt;center&gt;1.监督学习（翻译完）&lt;/center&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.1. 广义线性模型&lt;ul&gt;
&lt;li&gt;1.1.1. 最小二乘法&lt;ul&gt;
&lt;li&gt;1.1.1.1. 最小二乘法复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.1.2. 岭回归&lt;ul&gt;
&lt;li&gt;1.1.2.1. 岭回归复杂度&lt;/li&gt;
&lt;li&gt;1.1.2.2. 参数设置:广义交叉验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.1.3. 套索算法&lt;ul&gt;
&lt;li&gt;1.1.3.1. 参数设置&lt;ul&gt;
&lt;li&gt;1.1.3.1.1. 交叉验证的使用&lt;/li&gt;
&lt;li&gt;1.1.3.1.2. 基于模型选择的信息标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.1.4. 弹性网原理&lt;/li&gt;
&lt;li&gt;1.1.5. 多任务的套索算法&lt;/li&gt;
&lt;li&gt;1.1.6. 最小角回归&lt;/li&gt;
&lt;li&gt;1.1.7. 最小角回归 套索&lt;ul&gt;
&lt;li&gt;1.1.7.1. 数学公式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.1.8. 正交匹配追踪算法 (OMP)&lt;/li&gt;
&lt;li&gt;1.1.9. 贝叶斯回归&lt;ul&gt;
&lt;li&gt;1.1.9.1. 贝叶斯岭回归&lt;/li&gt;
&lt;li&gt;1.1.9.2. 自动相关确定 - ARD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.1.10. 逻辑回归&lt;/li&gt;
&lt;li&gt;1.1.11. 随机梯度下降 - SGD&lt;/li&gt;
&lt;li&gt;1.1.12. 感知器&lt;/li&gt;
&lt;li&gt;1.1.13. 被动侵略算法&lt;/li&gt;
&lt;li&gt;1.1.14. 随机抽样一致:增加异常值的鲁棒性&lt;/li&gt;
&lt;li&gt;1.1.15. 多项式回归: 基础函数的扩展线性模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.2. 支持向量机&lt;ul&gt;
&lt;li&gt;1.2.1. 分类&lt;ul&gt;
&lt;li&gt;1.2.1.1. 多类分类&lt;/li&gt;
&lt;li&gt;1.2.1.2. 评分与概率&lt;/li&gt;
&lt;li&gt;1.2.1.3. 不平衡问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.2.2. 回归&lt;/li&gt;
&lt;li&gt;1.2.3. 密度估计,新颖性检测&lt;/li&gt;
&lt;li&gt;1.2.4. 复杂度&lt;/li&gt;
&lt;li&gt;1.2.5. 实际中使用技巧&lt;/li&gt;
&lt;li&gt;1.2.6. 核函数&lt;ul&gt;
&lt;li&gt;1.2.6.1. 自定义核&lt;ul&gt;
&lt;li&gt;1.2.6.1.1. 用 Python 函数作为核函数&lt;/li&gt;
&lt;li&gt;1.2.6.1.2. 使用 Gram 矩阵&lt;/li&gt;
&lt;li&gt;1.2.6.1.3. RBF 内核参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.2.7. 数学公式&lt;ul&gt;
&lt;li&gt;1.2.7.1. SVC&lt;/li&gt;
&lt;li&gt;1.2.7.2. NuSVC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.2.8. 实际细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.3. 随机梯度下降&lt;ul&gt;
&lt;li&gt;1.3.1. 分类&lt;/li&gt;
&lt;li&gt;1.3.2. 回归&lt;/li&gt;
&lt;li&gt;1.3.3. 稀疏数据的随机梯度下降&lt;/li&gt;
&lt;li&gt;1.3.4. 复杂度&lt;/li&gt;
&lt;li&gt;1.3.5. 实际中的使用技巧&lt;/li&gt;
&lt;li&gt;1.3.6. 数学公式&lt;ul&gt;
&lt;li&gt;1.3.6.1. SGD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.3.7. 实际细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.4. 最近邻算法&lt;ul&gt;
&lt;li&gt;1.4.1. 无监督的近邻算法&lt;ul&gt;
&lt;li&gt;1.4.1.1. 找到最近邻&lt;/li&gt;
&lt;li&gt;1.4.1.2. KDTree 和 BallTree 类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.4.2. 最近邻分类问题&lt;/li&gt;
&lt;li&gt;1.4.3. 最近邻回归问题&lt;/li&gt;
&lt;li&gt;1.4.4. 最近邻算法&lt;ul&gt;
&lt;li&gt;1.4.4.1. 暴力&lt;/li&gt;
&lt;li&gt;1.4.4.2. K-D Tree&lt;/li&gt;
&lt;li&gt;1.4.4.3. Ball Tree&lt;/li&gt;
&lt;li&gt;1.4.4.4. 最近邻算法的选择&lt;/li&gt;
&lt;li&gt;1.4.4.5. leaf_size 的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.4.5. 最近质心分类&lt;ul&gt;
&lt;li&gt;1.4.5.1. 最近的缩小质心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.5. 高斯过程&lt;ul&gt;
&lt;li&gt;1.5.1. 例子&lt;ul&gt;
&lt;li&gt;1.5.1.1. 一个回归例子的介绍&lt;/li&gt;
&lt;li&gt;1.5.1.2. 数据拟合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.5.2. 数学公式&lt;ul&gt;
&lt;li&gt;1.5.2.1. 开始的假设&lt;/li&gt;
&lt;li&gt;1.5.2.2. 最佳线性无偏预测 (BLUP)&lt;/li&gt;
&lt;li&gt;1.5.2.3. 经验最佳线性无偏预测 (EBLUP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.5.3. 相关模型&lt;/li&gt;
&lt;li&gt;1.5.4. 回归模型&lt;/li&gt;
&lt;li&gt;1.5.5. 实际细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.6. 交叉分解&lt;/li&gt;
&lt;li&gt;1.7. 朴素贝叶斯&lt;ul&gt;
&lt;li&gt;1.7.1. 高斯朴素贝叶斯&lt;/li&gt;
&lt;li&gt;1.7.2. 多项式朴素贝叶斯&lt;/li&gt;
&lt;li&gt;1.7.3. 伯努利朴素贝叶斯&lt;/li&gt;
&lt;li&gt;1.7.4. 核心朴素贝叶斯模型拟合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.8. 决策树&lt;ul&gt;
&lt;li&gt;1.8.1. 分类&lt;/li&gt;
&lt;li&gt;1.8.2. 回归&lt;/li&gt;
&lt;li&gt;1.8.3. 多输出问题&lt;/li&gt;
&lt;li&gt;1.8.4. 复杂度&lt;/li&gt;
&lt;li&gt;1.8.5. 实际中的使用技巧&lt;/li&gt;
&lt;li&gt;1.8.6. 树算法: ID3, C4.5, C5.0 and CART&lt;/li&gt;
&lt;li&gt;1.8.7. 数学公式&lt;ul&gt;
&lt;li&gt;1.8.7.1. 分类标准&lt;/li&gt;
&lt;li&gt;1.8.7.2. 回归标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.9. 所有方法&lt;ul&gt;
&lt;li&gt;1.9.1. 套袋元估计&lt;/li&gt;
&lt;li&gt;1.9.2. 随机森林&lt;ul&gt;
&lt;li&gt;1.9.2.1. 随机森林&lt;/li&gt;
&lt;li&gt;1.9.2.2. 绝对随机森林&lt;/li&gt;
&lt;li&gt;1.9.2.3. 参数&lt;/li&gt;
&lt;li&gt;1.9.2.4. 并行化&lt;/li&gt;
&lt;li&gt;1.9.2.5. 特征重要性评价&lt;/li&gt;
&lt;li&gt;1.9.2.6. 完全随机森林嵌入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.9.3. AdaBoost算法&lt;ul&gt;
&lt;li&gt;1.9.3.1. 使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.9.4. 梯度推进树&lt;ul&gt;
&lt;li&gt;1.9.4.1. 分类&lt;/li&gt;
&lt;li&gt;1.9.4.2. 回归&lt;/li&gt;
&lt;li&gt;1.9.4.3. 适配额外的弱学习器&lt;/li&gt;
&lt;li&gt;1.9.4.4. 控制树的大小&lt;/li&gt;
&lt;li&gt;1.9.4.5. 数学公式&lt;ul&gt;
&lt;li&gt;1.9.4.5.1. 损失函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.9.4.6. 正规化&lt;ul&gt;
&lt;li&gt;1.9.4.6.1. 收缩&lt;/li&gt;
&lt;li&gt;1.9.4.6.2. 二次采样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.9.4.7. 解释&lt;ul&gt;
&lt;li&gt;1.9.4.7.1. 特征重要性&lt;/li&gt;
&lt;li&gt;1.9.4.7.2. 部分依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.10. 多用户多标记算法&lt;ul&gt;
&lt;li&gt;1.10.1. 多标记分类格式&lt;/li&gt;
&lt;li&gt;1.10.2. One-Vs-The-Rest&lt;ul&gt;
&lt;li&gt;1.10.2.1. 多类学习&lt;/li&gt;
&lt;li&gt;1.10.2.2. 多标签学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.10.3. One-Vs-One&lt;ul&gt;
&lt;li&gt;1.10.3.1. 多类学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.10.4. 纠错输出编码&lt;ul&gt;
&lt;li&gt;1.10.4.1. 多类学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.11. 特征选择&lt;ul&gt;
&lt;li&gt;1.11.1. 移除低方差特征&lt;/li&gt;
&lt;li&gt;1.11.2. 单变量特征选择&lt;/li&gt;
&lt;li&gt;1.11.3. 递归特征消除&lt;/li&gt;
&lt;li&gt;1.11.4. L1-based 特征选择&lt;ul&gt;
&lt;li&gt;1.11.4.1. 选择非零系数&lt;/li&gt;
&lt;li&gt;1.11.4.2. 随机稀疏模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.11.5. Tree-based 特征选择&lt;/li&gt;
&lt;li&gt;1.11.6. 特征选择是管道的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.12. 半监督&lt;ul&gt;
&lt;li&gt;1.12.1. 标签传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.13. 线性和二次判定分析&lt;ul&gt;
&lt;li&gt;1.13.1. 使用 LDA 降维&lt;/li&gt;
&lt;li&gt;1.13.2. 数学观&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1.14. 保序回归&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>如何高效的评估竞品收录覆盖率</title><link href="http://saerdna.github.io/posts/tech/how_to_assessment_the_competing_products_coverage_efficient-zh.html" rel="alternate"></link><updated>2014-05-22T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2014-05-22:posts/tech/how_to_assessment_the_competing_products_coverage_efficient-zh.html</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;好久没来这里写东西了，作为一个技术人员,还是得写点干货。 也算是对工作中一些难点的感悟吧，有些习惯总得坚持下去才能见到收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正式入职百度半年之后因为某些&lt;del&gt;特殊原因&lt;/del&gt;，我被transfer到了百度的spider部门。 这个部门就是负责抓取互联网上对百度有意义的资源(此处泛指网页)。&lt;/p&gt;
&lt;p&gt;大家都知道，网站是有压力瓶颈的，对于一个站点，不能无限制的抓取。如果&lt;code&gt;抓取量+用户访问量&amp;gt;网站实际可承受压力&lt;/code&gt;，网站就会出现诸如404等无法正常响应的情况。&lt;/p&gt;
&lt;p&gt;而对于整个百度而言，抓取的出口也是有限的,每天抓取的总量就那么多。 所以，如何在有限的资源下尽可能的将有价值的网页抓回来就是一个难题。&lt;/p&gt;
&lt;p&gt;评估一个抓取服务质量的好坏，在于这个服务收录整个集合的百分比。&lt;/p&gt;
&lt;p&gt;在我接触这个方向时，对于整个服务的质量评估，基本是处于人工加半自动化工具的方式来评估。 而且现成的工具效率也偏低，只能用来做为评估手段，利用产出数据由于数据量太小，没法用于实际的生产环境。&lt;/p&gt;
&lt;p&gt;当时我的导师给了我一个任务，就是实现一个自动评估模块，日处理千万量级的url，用以检测百度是否都收录了这些url或者这些url的相同资源。&lt;/p&gt;
&lt;p&gt;这个问题的难点在于，怎么判断2个不同的url是否是相同资源。 &lt;code&gt;相同资源:同一个站点下指向同一个网页的不同url，两者互为相同资源&lt;/code&gt; 简单来说就是2个不同的url，使用浏览器打开后都为同一个实际页面。 对于收录而言，只需要收录了其中一条就算是good case。 所以需要做的事情，就是比较竞品收录的url和内部收录的url两个集合的交集。&lt;/p&gt;
&lt;h3&gt;二种解决方案&lt;/h3&gt;
&lt;p&gt;基于页面内容的相似性检测，比如正文，标题，content等 &lt;strong&gt;1.优点：理论准确性高，长线来看效果好 2.缺点：基础数据要求高，既然已经抓回了网页，就没必要评估是否已经收录。 3.缺点：做的事情和dedup类似，重复造轮子了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于url长相的相似性检测。 &lt;strong&gt;1.优点：新东西，之前没人做过类似的。基础数据依赖简单，仅需要url作为原始输入 2.缺点：容易出现技术上难以解决的badcase，遇到这类情况只能靠白名单机制解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后从性价比的角度考虑，选择了第二种相对简单靠谱的方案。&lt;/p&gt;
&lt;h3&gt;总体策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对于每个竞品收录的url，先计算出一个或多个feature，在同一个feature下可以存在不同的资源，但是相同的资源必需存在同一个feature。 feature主要考虑从url的id以及path入手，如 http://bbs.byr.cn/#!article/WorkLife/932151 feature:(WorkLife, 932151) or (932151) 可用的方法有很多，比如提取query部分的最长数字等。 将已经收录的url，通过trie去匹配特征，如果url中存在特征字符串，才会进入到下一轮计算。 通过这种方式，我们可以将需要进行比较的url pair缩小到一个相对可控的范围内。&lt;/li&gt;
&lt;li&gt;通过对过滤后的集合进行两两比较，判断竞品url是否存在一个相似url在已收录集合。 这里主要需要比较的是query部分，将query部分相似度最大的那组url认为是相同资源组 当然，还需要剔除一些无效参数的干扰，这里就不细说了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;效果&lt;/h3&gt;
&lt;p&gt;第一版的准确和召回均在90%以上，这主要还是依赖于目前dedup策略的效果已经很高，收录部分基本没什么重复和垃圾。 还有就是本身百度收录还是做得很好的，大部分url都能找到相同资源，很特殊的一小部分case也都是一些特殊参数导致的误识别，目前还没发现url长相一致，但指向不同网页的case。所以后继算法上基本不做优化，主要都是通过配置白名单解决。&lt;/p&gt;</summary></entry><entry><title>随笔</title><link href="http://saerdna.github.io/posts/essay/essay-zh.html" rel="alternate"></link><updated>2013-09-09T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2013-09-09:posts/essay/essay-zh.html</id><summary type="html">&lt;h3&gt;插件&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在等程序出结果，想着似乎该写点什么。&lt;/p&gt;
&lt;p&gt;就称之为随笔吧，估计以后会有个系列也说不定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前说了要弄一个自动填写淘宝试用频道答案的&lt;a href="https://github.com/Saerdna/try-taobao-helper"&gt;插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;周末花了点时间，总算是弄好了，虽然还有些小bug，但用着还是很顺手的。&lt;/p&gt;
&lt;p&gt;最烦就是重复的手工劳动了。&lt;/p&gt;
&lt;p&gt;本来还想弄成自动扫描商品来着，后面发现每天申请试用还有上限。&lt;/p&gt;
&lt;p&gt;一想到还得先弄一批淘宝的帐号就闹心，还是算了吧。&lt;/p&gt;
&lt;h3&gt;产品&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一切没有收入的开发都是无用功&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次开发完这个小插件后我就开始想着拿这货弄些什么东西来赚钱－ －。&lt;/p&gt;
&lt;p&gt;一开始也没啥思路的，后面想想目前国内互联网小众还是得靠广告维生。&lt;/p&gt;
&lt;p&gt;是不是可以写一个插件让大家装浏览器上，自动分析当前页面的空白部分并展现广告，我就通过这部分广告获得收入并提供分成给大家。&lt;/p&gt;
&lt;p&gt;当然，我拿小头，大家伙拿大头。&lt;/p&gt;
&lt;p&gt;我希望这么做可以让互联网趋于服务化，用户对于服务就该付费。&lt;/p&gt;
&lt;p&gt;广告部分的收入，既然用户消费产生了经济收益，这部分就该还给用户。&lt;/p&gt;
&lt;p&gt;这东西说起来简单，但是实际也挺难的。&lt;/p&gt;
&lt;p&gt;技术层面能做的就有分成系统和用户行为分析以及站点分析。&lt;/p&gt;
&lt;p&gt;还得考虑做大后会不会被原始广告商掐死，移动端似乎完全没法开展。&lt;/p&gt;
&lt;p&gt;唯一的亮点在于这个产品以用户为中心，不需要看站长的脸色，也能在这么复杂的环境下插一脚。&lt;/p&gt;
&lt;p&gt;这个事情我希望自己能在年底前把基础的东西做好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插件端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1.交互模块
2.展现模块
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1.分成系统
2.用户接入
3.站点分析
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个事情只能拿自己平时的时间来弄了。&lt;/p&gt;
&lt;p&gt;这个也是我第一次如此感兴趣的一个项目。&lt;/p&gt;
&lt;p&gt;加油。&lt;/p&gt;</summary></entry><entry><title>关于淘宝试用频道的一些想法</title><link href="http://saerdna.github.io/posts/tech/about_taobao_try-zh.html" rel="alternate"></link><updated>2013-08-27T00:30:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2013-08-27:posts/tech/about_taobao_try-zh.html</id><summary type="html">&lt;p&gt;这两天看了下淘宝的&lt;a href="http://try.taobao.com/"&gt;试用频道&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;发现里面还挺多好东西的，就是申请的人太多了。&lt;/p&gt;
&lt;p&gt;随便个什么东西都有几百号人在领，好一点的基本都上万人。&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="http://saerdna.github.io/images/taobao_try_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;(这泥马大家都没见过翻盖手机么－ －)&lt;/p&gt;
&lt;p&gt;这还没什么，关键是这货是淘宝弄出来让大家写试用报告的，我看了下。&lt;/p&gt;
&lt;p&gt;似乎很多人把报告什么的给无视了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2" src="http://saerdna.github.io/images/taobao_try_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;(马德，是不是剩下的那9个人被大米给弄成食物中毒所以没机会完成这份报告－ －)&lt;/p&gt;
&lt;p&gt;出于职业习惯以及个人需求，我打算弄一个chrome插件来帮助我自动填写试用申请的答案。&lt;/p&gt;
&lt;p&gt;至于为什么不弄个本地的spider然后post数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我还不想被淘宝给封号&lt;/li&gt;
&lt;li&gt;里面很多化妆品不大合我的style，还是留给辛苦的女生们吧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;出于长远的打算，插件的可移植性比本地写spider要靠谱。&lt;/p&gt;
&lt;p&gt;以后孝敬老爸老妈的好东西啊！&lt;/p&gt;
&lt;p&gt;长线方案还得弄一个自动写报告的模块。&lt;/p&gt;
&lt;p&gt;这就得看人力了，做得不好还不如自己写。&lt;/p&gt;
&lt;p&gt;估计后面有一堆临时工在审核，一不小心进了黑名单以后就不好领了。&lt;/p&gt;
&lt;p&gt;简单说下思路&lt;/p&gt;
&lt;p&gt;提取图片中的链接和问题&lt;/p&gt;
&lt;p&gt;&lt;img alt="3" src="http://saerdna.github.io/images/taobao_try_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;解析商品页面对应的描述部分即可。&lt;/p&gt;
&lt;p&gt;至于自动写报告的模块。找几家大的天猫店或者皇冠店铺。&lt;/p&gt;
&lt;p&gt;把字数比较多的评论抓出来，然后替换关键词。&lt;/p&gt;
&lt;p&gt;估计这么弄出来的报告可以混过70%的临时工。&lt;/p&gt;</summary></entry><entry><title>别再浪费时间了</title><link href="http://saerdna.github.io/posts/life/don't_waste_time-zh.html" rel="alternate"></link><updated>2013-08-26T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2013-08-26:posts/life/don't_waste_time-zh.html</id><summary type="html">&lt;p&gt;又熬夜了，上一周计划的事情才做了一半多一点。&lt;/p&gt;
&lt;p&gt;发觉自己有点陷入高一，高二那时候的懒惰状态。&lt;/p&gt;
&lt;p&gt;想得太多，做得太少。&lt;/p&gt;
&lt;p&gt;再这么下去，不用等公司自然淘汰了，自己首先就得把自己玩死。&lt;/p&gt;
&lt;p&gt;这一个月租了房子之后，整个人都懒散了下来。&lt;/p&gt;
&lt;p&gt;看视频，偶尔玩玩游戏，刷刷微博，看看小说。&lt;/p&gt;
&lt;p&gt;时间就是这么一点一点被消磨光的。&lt;/p&gt;
&lt;p&gt;人的精力都是有限的。什么是长远的发展，自己得看清楚。不要每次都等到来不及了再去匆匆忙忙的赶工。很多机会就是在这种消磨和匆忙中流失了。&lt;/p&gt;</summary></entry><entry><title>It's My life</title><link href="http://saerdna.github.io/posts/life/It's_My_life-zh.html" rel="alternate"></link><updated>2013-08-19T00:00:00+08:00</updated><author><name>Saerdna</name></author><id>tag:saerdna.github.io,2013-08-19:posts/life/It's_My_life-zh.html</id><summary type="html">&lt;p&gt;很久以前也许我也没想过自己会走进互联网这个圈子。&lt;/p&gt;
&lt;p&gt;毕业一年了，来百度的时间也将近3年之久。&lt;/p&gt;
&lt;p&gt;现在的情况也说不上是好还是坏吧。&lt;/p&gt;
&lt;p&gt;这种感觉就和在游戏里面打装备，可是你刚刚走出副本，就爆出了一件不错的装备。&lt;/p&gt;
&lt;p&gt;我相信我可以做得很好，但是却找不到那条通向梦想的道路。&lt;/p&gt;
&lt;p&gt;也每当这个时候，我才会特别相信所谓的厚积薄发。&lt;/p&gt;</summary><category term="feeling"></category></entry></feed>